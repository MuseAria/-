def longestPalindrome(self, s: str) -> str:
        # 处理字符串，插入特殊字符来统一奇偶回文情况
        t = "#" + "#".join(s) + "#"
        n = len(t)
        p = [0] * n  # p[i] 表示以 t[i] 为中心的回文半径
        center, right = 0, 0  # center 是回文中心，right 是回文的右边界
        max_len, start = 0, 0  # max_len 是最长回文的半径，start 是回文的起始位置
        for i in range(n):
            # 对称位置
            mirror = 2 * center - i
            
            if i < right:
                p[i] = min(right - i, p[mirror])  # 使用对称点的回文信息来初始化 p[i]
            
            # 尝试扩展回文半径
            while i + p[i] + 1 < n and i - p[i] - 1 >= 0 and t[i + p[i] + 1] == t[i - p[i] - 1]:
                p[i] += 1
            
            # 如果回文的右边界超出了 right，更新 center 和 right
            if i + p[i] > right:
                center, right = i, i + p[i]
                
            # 记录最长回文半径
            if p[i] > max_len:
                max_len = p[i]
                start = (i - p[i]) // 2  # 从 t 中恢复原字符串的起始位置
        return s[start:start + max_len]
